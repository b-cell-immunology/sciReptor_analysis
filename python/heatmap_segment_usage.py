# -*- coding: utf-8 -*-
"""
Created on Sun Jun 21 14:15:12 2015

@author: katharina
"""

import bcelldb_init as bcelldb
import igdb_plotting as igplt
import numpy as np
import numpy.random as random
import MySQLdb as mysql
import matplotlib.pyplot as plt
import matplotlib as mpl
import sys
import colorsys
import argparse
import igdb_queries as igdbq
import igdb_plotting as igdbplt


db = 'healthy'
library = 'library_scireptor'
resolve = 'families' # or genes # or VJ
locus = 'H'
seg_type = 'J' # or J

connection = mysql.connect(db=db,read_default_file="~/.my.cnf", read_default_group='mysql_igdb')
cursor = connection.cursor()

####
#### Build heavy_light table if necessary
####

# generate event list. Will later on be generated by another program and taken up by pickle (or called as module).

event_names, event_statements = igdbq.read_eventfile('healthy_donors.events', db)

def get_list_data (event_statement):
    if resolve == 'families':
        paired_statement = "SELECT \
            COUNT(*) as cnt, H_VDJ.seg_family, KL_VDJ.seg_family \
            FROM \
            (SELECT seg_family, event_id FROM heavy_light \
            JOIN VDJ_segments \
            ON heavy_light.H_seq_id = VDJ_segments.seq_id \
            JOIN %s.VDJ_library on VDJ_library.VDJ_id = VDJ_segments.VDJ_id \
            where igblast_rank=1 and VDJ_segments.type = '%s') as H_VDJ \
            JOIN \
            (SELECT seg_family, event_id FROM heavy_light \
            JOIN VDJ_segments \
            ON heavy_light.KL_seq_id = VDJ_segments.seq_id \
            JOIN %s.VDJ_library on VDJ_library.VDJ_id = VDJ_segments.VDJ_id \
            where igblast_rank=1 and VDJ_segments.type = '%s') as KL_VDJ \
            JOIN event ON event.event_id = H_VDJ.event_id \
            AND event.event_id = KL_VDJ.event_id \
            WHERE event.event_id IN (%s) \
            GROUP BY CONCAT(H_VDJ.seg_family, KL_VDJ.seg_family) \
            ORDER BY H_VDJ.seg_family, KL_VDJ.seg_family \
            " % (library, seg_type, library, seg_type, event_statement)
    elif resolve == 'genes':
        paired_statement = "SELECT \
            COUNT(*) as cnt, H_VDJ.seg_name, KL_VDJ.seg_name \
            FROM \
            (SELECT concat(seg_family, '-', seg_gene) as seg_name, event_id FROM heavy_light \
            JOIN VDJ_segments \
            ON heavy_light.H_seq_id = VDJ_segments.seq_id \
            JOIN %s.VDJ_library on VDJ_library.VDJ_id = VDJ_segments.VDJ_id \
            where igblast_rank=1 and VDJ_segments.type = '%s') as H_VDJ \
            JOIN \
            (SELECT concat(seg_family, '-', seg_gene) as seg_name, event_id FROM heavy_light \
            JOIN VDJ_segments \
            ON heavy_light.KL_seq_id = VDJ_segments.seq_id \
            JOIN %s.VDJ_library on VDJ_library.VDJ_id = VDJ_segments.VDJ_id \
            where igblast_rank=1 and VDJ_segments.type = '%s') as KL_VDJ \
            JOIN event ON event.event_id = H_VDJ.event_id \
            AND event.event_id = KL_VDJ.event_id \
            WHERE event.event_id IN (%s) \
            GROUP BY CONCAT(H_VDJ.seg_name, KL_VDJ.seg_name) \
            ORDER BY H_VDJ.seg_name, KL_VDJ.seg_name \
            " % (library,  seg_type, library, seg_type, event_statement)
    elif resolve == 'VJ':
        paired_statement = "SELECT \
            COUNT(*) as cnt, J.seg_name, V.seg_name \
            FROM \
            (SELECT concat(seg_family, '-', seg_gene) as seg_name, event_id FROM heavy_light \
            JOIN VDJ_segments \
            ON heavy_light.H_seq_id = VDJ_segments.seq_id \
            JOIN %s.VDJ_library on VDJ_library.VDJ_id = VDJ_segments.VDJ_id \
            where igblast_rank=1 and VDJ_segments.type = 'V') as V \
            JOIN \
            (SELECT seg_family as seg_name, event_id FROM heavy_light \
            JOIN VDJ_segments \
            ON heavy_light.H_seq_id = VDJ_segments.seq_id \
            JOIN %s.VDJ_library on VDJ_library.VDJ_id = VDJ_segments.VDJ_id \
            where igblast_rank=1 and VDJ_segments.type = 'J') as J \
            JOIN event ON event.event_id = V.event_id \
            AND event.event_id = J.event_id \
            WHERE event.event_id IN (%s) \
            GROUP BY CONCAT(V.seg_name, J.seg_name) \
            ORDER BY V.seg_name, J.seg_name \
            " % (library, library, event_statement)
            
    cursor.execute(paired_statement)
    gene_rows = cursor.fetchall()
    
    n_list1_list2_dict = {}
    n_list2_list1_dict = {}
    list1 = []
    list2 = []
    
    for row in gene_rows:
        try:
            n_list1_list2_dict[row[1]][row[2]] = row[0]
        except KeyError:
            n_list1_list2_dict[row[1]] = {}
            n_list1_list2_dict[row[1]][row[2]] = row[0]
        try:
            n_list2_list1_dict[row[2]][row[1]] = row[0]
        except KeyError:
            n_list2_list1_dict[row[2]] = {}
            n_list2_list1_dict[row[2]][row[1]] = row[0]
        list1.append(row[1])
        list2.append(row[2])
    
    return list1, list2, n_list1_list2_dict, n_list2_list1_dict

def get_heatmap_array (event_name, list1_names, list2_names, n_list1_list2_dict):
    cols = len(list1_names)
    rows = len(list2_names)
    seg_usage_array = np.zeros((cols,rows))
    
    for i, col_name in zip(range(cols), list1_names):
        for j, row_name in zip(range(rows), list2_names):
            try:
                seg_usage_array[i][j] = n_list1_list2_dict[col_name][row_name]
            except KeyError:
                pass
    number = np.sum(seg_usage_array)
    # normalize
    seg_usage_array = seg_usage_array/np.sum(seg_usage_array)
    return seg_usage_array, number
    
    
list_data_event_dict = {}
all_list1_names = []
all_list2_names = []
for event_name, event_st in zip(event_names, event_statements):
    list_data_event_dict[event_name] = get_list_data(event_st)
    all_list1_names.append(list_data_event_dict[event_name][0])
    all_list2_names.append(list_data_event_dict[event_name][1])

combined_list1 = []
for item in all_list1_names:
    combined_list1 += item
list1_names = list(set(combined_list1))
list1_names.sort()

combined_list2 = []
for item in all_list2_names:
    combined_list2 += item
list2_names = list(set(combined_list2))
list2_names.sort()

array_event_dict = {} 
number_event_dict = {} 
for event_name in event_names:
    n_list1_list2_dict = list_data_event_dict[event_name][2]
    array_event_dict[event_name], number_event_dict[event_name] = get_heatmap_array(event_name, list1_names, list2_names, n_list1_list2_dict)
vmin = np.min(array_event_dict.values())
vmax = np.max(array_event_dict.values())


###
# PLOTTING
###

# define size

n_events = len(event_names)

F = plt.figure(1, 
               (0.4*n_events*len(list1_names)+0.05+0.04*len(list1_names), #width
                0.4*len(list2_names))) #height
F.clf()

from mpl_toolkits.axes_grid1 import ImageGrid
grid = ImageGrid(F, 111,
          nrows_ncols = (1, n_events),
          direction="row",
          axes_pad = 0.05,
          add_all=True,
          share_all = True,
          cbar_location="right",
          cbar_mode="single",
          cbar_size="10%",
          cbar_pad=0.05,
          )
norm = matplotlib.colors.Normalize(vmax=vmax, vmin=vmin)

for ax, event_name in zip(grid, event_names):
    im = ax.imshow(array_event_dict[event_name].T, norm=norm,
                   origin="upper",
                   interpolation="none", cmap='binary')
cbar = ax.cax.colorbar(im)
ax.cax.toggle_label(True)
cbar.set_label_text('Relative frequency')

grid[0].set_yticks(range(len(list2_names)))
grid[0].set_yticklabels(list2_names)  

for ax, im_title in zip(grid, event_names):
    ax.set_xlabel(im_title + "\n (n =  " + str(int(number_event_dict[im_title])) + ")")
    ax.tick_params(labelbottom='off',labeltop='on',
                   bottom ='off', top = 'off',
                   right= 'off', left = 'off')
    ax.set_xticks(range(len(list1_names)))
    ax.set_xticklabels(list1_names, rotation=90)

igdbplt.plot_log('Segment association', sys.args)
plt.draw()       
plt.show()


filename = '%s_%s_%s.pdf' % (db,resolve,seg_type)
plt.savefig(filename)      