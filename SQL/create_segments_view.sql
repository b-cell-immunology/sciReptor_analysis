# Name:			create_segments_view.sql
# Verson:		0.1.1  (2015-03-18)
# Author(s):	Christian Busse
# Maintainer:	Christian Busse (christian.busse@dkfz-heidelberg.de)
# Licence:		AGPL3
# Provides:		A single table containing basic informations about an event, most notably the utilitzed segments.
# Requires:		temporary tables generated by "create_temp_table_VDJ.sql"
# Comment:		*Attention*: This function is computationally expensive and can take up to one hour to complete,
# 				depending on the size of the database,timeout limits of the SQL client have to be increased accordingly.

DROP TABLE IF EXISTS temp_segments_view;

CREATE TEMPORARY TABLE temp_segments_view AS (
	SELECT
		`event`.event_id,
		`event`.plate,
		`event`.well,
		donor.donor_identifier,
		sample.tissue,
		sort.population,
		sort.antigen,
		temp_associated.igh_segment_v,
		temp_associated.igh_segment_d,
		temp_associated.igh_segment_j,
		temp_associated.igh_cdr3,
		temp_associated.igh_segment_c,
		temp_associated.igk_segment_v,
		temp_associated.igk_segment_j,
		temp_associated.igk_cdr3,
		temp_associated.igk_segment_c,
		temp_associated.igl_segment_v,
		temp_associated.igl_segment_j,
		temp_associated.igl_cdr3,
		temp_associated.igl_segment_c
	FROM (
		SELECT 
			temp_heavy.event_id			AS igh_segment_event_id,
			temp_heavy.v_segment_name	AS igh_segment_v,
			temp_heavy.d_segment_name	AS igh_segment_d,
			temp_heavy.j_segment_name	AS igh_segment_j,
			temp_heavy.CDR3				AS igh_cdr3,
			temp_heavy.c_segment_name	AS igh_segment_c,
			temp_kappa.v_segment_name	AS igk_segment_v,
			temp_kappa.j_segment_name	AS igk_segment_j,
			temp_kappa.CDR3				AS igk_cdr3,
			temp_kappa.c_segment_name	AS igk_segment_c,
			temp_lambda.v_segment_name	AS igl_segment_v,
			temp_lambda.j_segment_name	AS igl_segment_j,
			temp_lambda.CDR3			AS igl_cdr3,
			temp_lambda.c_segment_name	AS igl_segment_c
		FROM (
			# Get heavy chain information
			#
			SELECT 
				sequences.event_id,
				temp_table_H_VDJ.v_segment_name,
				temp_table_H_VDJ.d_segment_name,
				temp_table_H_VDJ.j_segment_name,
				CDR.prot_seq AS CDR3,
				temp_table_H_VDJ.c_segment_name
			FROM temp_table_H_VDJ
			INNER JOIN (
				# The following query basically returns a seq_id and a CDR3 protein sequence, however it also contains
                # an additional logic that the sequence with the lower consensus_rank will be given preferences unless it
                # does contain a stop codon in CDR3. This is implemented via a LEFT JOIN which is one way to select for
                # group-wise extrema in MySQL (comparable to the OVER ... PARTION BY statement in PostgreSQL).
                #
				SELECT
					temp_table_functionality_1.seq_id,
					temp_table_functionality_1.prot_seq
				FROM (
					SELECT 
						sequences.event_id,
						sequences.seq_id,
						sequences.consensus_rank,
						CDR_FWR.prot_seq,
						CDR_FWR.stop_codon 
					FROM sequences
					INNER JOIN CDR_FWR
					ON sequences.seq_id=CDR_FWR.seq_id
					WHERE locus='H'
						AND region='CDR3'
						AND stop_codon = 0
				) AS temp_table_functionality_1
				LEFT JOIN (
					SELECT 
						sequences.event_id,
						sequences.seq_id,
						sequences.consensus_rank,
						CDR_FWR.prot_seq,
						CDR_FWR.stop_codon 
					FROM sequences
					INNER JOIN CDR_FWR
					ON sequences.seq_id=CDR_FWR.seq_id
					WHERE locus='H'
						AND region='CDR3'
						AND stop_codon = 0
				) AS temp_table_functionality_2
				ON temp_table_functionality_1.event_id = temp_table_functionality_2.event_id 
					AND temp_table_functionality_1.consensus_rank > temp_table_functionality_2.consensus_rank
				WHERE temp_table_functionality_2.event_id IS NULL
			) AS CDR
			INNER JOIN sequences
			ON temp_table_H_VDJ.seq_id = CDR.seq_id
				AND temp_table_H_VDJ.seq_id = sequences.seq_id
		) AS temp_heavy
		LEFT OUTER JOIN (
			# Get kappa chain information
			#
			SELECT 
				sequences.event_id,
				temp_table_K_VJ.v_segment_name,
				temp_table_K_VJ.j_segment_name,
				CDR.prot_seq AS CDR3,
				temp_table_K_VJ.c_segment_name
			FROM temp_table_K_VJ
			INNER JOIN (
				SELECT
					temp_table_functionality_1.seq_id,
					temp_table_functionality_1.prot_seq
				FROM (
					SELECT 
						sequences.event_id,
						sequences.seq_id,
						sequences.consensus_rank,
						CDR_FWR.prot_seq,
						CDR_FWR.stop_codon 
					FROM sequences
					INNER JOIN CDR_FWR
					ON sequences.seq_id=CDR_FWR.seq_id
					WHERE locus='K'
						AND region='CDR3'
						AND stop_codon = 0
				) AS temp_table_functionality_1
				LEFT JOIN (
					SELECT 
						sequences.event_id,
						sequences.seq_id,
						sequences.consensus_rank,
						CDR_FWR.prot_seq,
						CDR_FWR.stop_codon 
					FROM sequences
					INNER JOIN CDR_FWR
					ON sequences.seq_id=CDR_FWR.seq_id
					WHERE locus='K'
						AND region='CDR3'
						AND stop_codon = 0
				) AS temp_table_functionality_2
				ON temp_table_functionality_1.event_id = temp_table_functionality_2.event_id 
					AND temp_table_functionality_1.consensus_rank > temp_table_functionality_2.consensus_rank
				WHERE temp_table_functionality_2.event_id IS NULL
			) AS CDR
			INNER JOIN sequences
			ON temp_table_K_VJ.seq_id = CDR.seq_id
				AND temp_table_K_VJ.seq_id = sequences.seq_id
			WHERE sequences.consensus_rank=1
		) AS temp_kappa
		ON temp_heavy.event_id = temp_kappa.event_id
		LEFT OUTER JOIN (
			# Get lambda chain information
			#
			SELECT 
				sequences.event_id,
				temp_table_L_VJ.v_segment_name,
				temp_table_L_VJ.j_segment_name,
				CDR.prot_seq AS CDR3,
				temp_table_L_VJ.c_segment_name
			FROM temp_table_L_VJ
			INNER JOIN (
				SELECT
					temp_table_functionality_1.seq_id,
					temp_table_functionality_1.prot_seq
				FROM (
					SELECT 
						sequences.event_id,
						sequences.seq_id,
						sequences.consensus_rank,
						CDR_FWR.prot_seq,
						CDR_FWR.stop_codon 
					FROM sequences
					INNER JOIN CDR_FWR
					ON sequences.seq_id=CDR_FWR.seq_id
					WHERE locus='L'
						AND region='CDR3'
						AND stop_codon = 0
				) AS temp_table_functionality_1
				LEFT JOIN (
					SELECT 
						sequences.event_id,
						sequences.seq_id,
						sequences.consensus_rank,
						CDR_FWR.prot_seq,
						CDR_FWR.stop_codon 
					FROM sequences
					INNER JOIN CDR_FWR
					ON sequences.seq_id=CDR_FWR.seq_id
					WHERE locus='L'
						AND region='CDR3'
						AND stop_codon = 0
				) AS temp_table_functionality_2
				ON temp_table_functionality_1.event_id = temp_table_functionality_2.event_id 
					AND temp_table_functionality_1.consensus_rank > temp_table_functionality_2.consensus_rank
				WHERE temp_table_functionality_2.event_id IS NULL
			) AS CDR
			INNER JOIN sequences
			ON temp_table_L_VJ.seq_id = CDR.seq_id
				AND temp_table_L_VJ.seq_id = sequences.seq_id
			WHERE sequences.consensus_rank=1
		) AS temp_lambda
		ON temp_heavy.event_id = temp_lambda.event_id
		WHERE temp_kappa.v_segment_name IS NOT NULL 
			OR temp_lambda.v_segment_name IS NOT NULL
	) AS temp_associated 
	INNER JOIN `event`
	INNER JOIN sort
	INNER JOIN sample
	INNER JOIN donor
	ON `event`.event_id = temp_associated.igh_segment_event_id
		AND sample.donor_id = donor.donor_id
		AND `event`.sort_id = sort.sort_id
		AND sort.sample_id = sample.sample_id
);
